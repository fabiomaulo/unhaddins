"Name"     = 'Hql'
"Author"   = 'Fabio Maulo'
"Version"  = '1.0.0'
"About"    = 'This grammar parses the query language for NHibernate'

"Start Symbol" = <Query>

! ------------------------------------------------- Sets

{ID Head}      = {Letter} + [_]
{ID Tail}      = {Alphanumeric} + [_]
{String Chars} = {Printable} + {HT} - [''\]
{Hex Digit} = {Digit} + [abcdefABCDEF]

! ------------------------------------------------- Terminals

Comment Start            = '/*'
Comment End            = '*/'
Comment Line            = '--'

Identifier = {ID Head}{ID Tail}*
Path = {ID Head}{ID Tail}* ('.' {ID Head}{ID Tail}*)+
StringLiteral = '' ( {String Chars} | '\' {Printable} | '''' )* ''
IntegerLiteral = {Digit}+
FloatLiteral = {Digit}+'.'{Digit}+ | {Digit}+'.'{Digit}+'e'{Digit}+
HexLiteral = 0x{Hex Digit}+
NotEqualOperator = '<>' | '!=' | '^='
Parameter = ':'{ID Head}{ID Tail}* | '?'

! ------------------------------------------------- Clauses
<Query> ::= <SelectStatement>
         |  <DeleteStatement>
         |  <UpdateStatement>
         |  <InsertStatement>

<DeleteStatement>::= DELETE <AliasedEntityName> <WhereClause>
                  |  DELETE FROM <AliasedEntityName> <WhereClause>

<UpdateStatement>::= UPDATE <AliasedEntityName> SET <AssignList> <WhereClause>
                  |  UPDATE VERSIONED <AliasedEntityName> SET <AssignList> <WhereClause>
                  |  UPDATE FROM <AliasedEntityName> SET <AssignList> <WhereClause>
                  |  UPDATE VERSIONED FROM <AliasedEntityName> SET <AssignList> <WhereClause>

<AssignList> ::= <EntityName> '=' <Expression> ',' <AssignList>
              |  <EntityName> '=' <Expression>

<InsertStatement>::= INSERT INTO <EntityName> '(' <EntityNameList> ')' <SelectStatement>

<SelectStatement> ::= <SelectClause> <FromClause>
                   |  <FromClause>

<SelectClause>::= SELECT <Restriction> <AliasedExpressionList>
               |  SELECT NEW <EntityName>'('<ExpressionList>')'

<FromClause> ::= FROM <AliasedEntityNameList> <JoinClauseChain> <WhereClause> <GroupByClause> <OrderByClause>

<JoinClauseChain> ::= <JoinClause> <JoinClauseChain>
                   |  <JoinClause> ',' <AliasedEntityNameList> <JoinClauseChain>
                   |  

<JoinClause> ::= <JoinDefinition> <WithClause>

<JoinDefinition> ::= LEFT JOIN <AliasedEntityName>
                  |  RIGHT JOIN <AliasedEntityName>
                  |  LEFT OUTER JOIN <AliasedEntityName>
                  |  RIGHT OUTER JOIN <AliasedEntityName>
                  |  FULL JOIN <AliasedEntityName>
                  |  INNER JOIN <AliasedEntityName>
                  |  LEFT JOIN FETCH <AliasedEntityName>
                  |  LEFT OUTER JOIN FETCH <AliasedEntityName>
                  |  INNER JOIN FETCH <AliasedEntityName>
                  |  JOIN <AliasedEntityName>
                  |  JOIN FETCH <AliasedEntityName>

<WithClause>      ::= WITH <Expression>
                   |  

<WhereClause> ::= WHERE <Expression>
               |  

<GroupByClause>::= 'GROUP BY' <ExpressionList> <HavingClause>
                |  

<HavingClause> ::= HAVING <Expression>
                |  

<OrderByClause>::= 'ORDER BY' <OrderList>
                |  

! ------------------------------------------------- Rules

<OrderList>::= <Expression> <OrderType> ',' <OrderList>
            |  <Expression> <OrderType>

<OrderType> ::= ASC
             |  DESC
             |  ASCENDING
             |  DESCENDING
             |  

<Restriction> ::= ALL
               |  DISTINCT
               |  

<AggregateExpression> ::= COUNT '(' '*' ')'
                       |  COUNT '(' <Restriction> <EntityName> ')'
                       |  COUNT '(' <Restriction> <CollectionExpression> ')'
                       |  AVG '(' <MathAddExpression> ')'
                       |  MIN '(' <MathAddExpression> ')'
                       |  MAX '(' <MathAddExpression> ')'

<FunctionExpression>::= Identifier '('')'
                     |  Identifier '('<ExpressionList>')'
                     |  CAST'('<Expression> AS Identifier')'

<CollectionExpression>::= ELEMENTS'(' Path ')'
                       |  INDICES'(' Path ')'

<EntityName> ::= Identifier | Path
<EntityNameList> ::= <EntityName> ',' <EntityNameList>
                  |  <EntityName>

<AliasedEntityName> ::= <EntityName> Identifier
                     |  <EntityName> AS Identifier
                     |  Identifier IN CLASS <EntityName>
                     |  Identifier IN ELEMENTS'(' Path ')'
                     |  <EntityName>

<AliasedEntityNameList> ::= <AliasedEntityName> ',' <AliasedEntityNameList>
                         |  <AliasedEntityName>

<AliasedExpression> ::= <Expression> AS Identifier | <Expression>
<AliasedExpressionList> ::= <AliasedExpression> ',' <AliasedExpressionList>  | <AliasedExpression>

<Expression> ::= <AndExpression> OR <Expression>
              |  <AndExpression>

<AndExpression> ::= <NotExpression> AND <AndExpression>
                 |  <NotExpression>

<NotExpression> ::= NOT <PredicateExpression>
                 |  <PredicateExpression>

<QuantifiedExpression>::= SOME Path
                       |  ALL Path
                       |  ANY Path
                       |  SOME <CollectionExpression>
                       |  ALL <CollectionExpression>
                       |  ANY <CollectionExpression>
                       |  SOME '(' <SelectStatement> ')'
                       |  ALL '(' <SelectStatement> ')'
                       |  ANY '(' <SelectStatement> ')'

<PredicateExpression> ::= <MathAddExpression> BETWEEN <MathAddExpression> AND <MathAddExpression>
                       |  <MathAddExpression> NOT BETWEEN <MathAddExpression> AND <MathAddExpression>
                       |  <Value> IS NOT NULL
                       |  <Value> IS NULL
                       |  <Value> IS EMPTY
                       |  <Value> IS NOT EMPTY
                       |  <MathAddExpression> LIKE <StringValueExpression> <LikeEscape>
                       |  <MathAddExpression> NOT LIKE <StringValueExpression> <LikeEscape>
                       |  <MathAddExpression> IN <Tuple>
                       |  <MathAddExpression> NOT IN <Tuple>
                       |  <MathAddExpression> IN <CollectionExpression>
                       |  <MathAddExpression> NOT IN <CollectionExpression>
                       |  <MemberPredicate>
                       |  <ExistsPredicate>
                       |  <MathAddExpression> '>' <MathAddExpression>
                       |  <MathAddExpression> '<' <MathAddExpression>
                       |  <MathAddExpression> '=' <MathAddExpression>
                       |  <MathAddExpression> '>=' <MathAddExpression>
                       |  <MathAddExpression> '<=' <MathAddExpression>
                       |  <MathAddExpression> NotEqualOperator <MathAddExpression>
                       |  <MathAddExpression> '>' <QuantifiedExpression>
                       |  <MathAddExpression> '<' <QuantifiedExpression>
                       |  <MathAddExpression> '=' <QuantifiedExpression>
                       |  <MathAddExpression> '>=' <QuantifiedExpression>
                       |  <MathAddExpression> '<=' <QuantifiedExpression>
                       |  <MathAddExpression> NotEqualOperator <QuantifiedExpression>
                       |  <MathAddExpression>

<LikeEscape>::= ESCAPE concatenation
             |  

<ExistsPredicate>::= EXISTS Path
                  |  EXISTS <CollectionExpression>
                  |  EXISTS '(' <SelectStatement> ')'

<MemberPredicate>::= Path MEMBER OF Path
                  |  Path MEMBER Path

<MathAddExpression> ::= <MathAddExpression> '+' <MathMultExpression>
                     |  <MathAddExpression> '-' <MathMultExpression>
                     |  <MathMultExpression>

<MathMultExpression>    ::= <MathMultExpression> '*' <MathNegateExpression>
                         |  <MathMultExpression> '/' <MathNegateExpression>
                         |  <MathNegateExpression>

<MathNegateExpression>  ::= '-' <Value>
                         |  <Value>

! ------------------------------ CASE rules ----------------------------

<CaseExpression>::= <SimpleCaseExpression> | <SearchedCaseExpression>

<SimpleCaseExpression>::= CASE <Value> <SimpleWhenClause> <ElseClause> END
<SearchedCaseExpression>::= CASE <SearchedWhenClause> <ElseClause> END

<SimpleWhenClause>::= WHEN <Value> THEN <CaseResult>
                   |  WHEN <Value> THEN <CaseResult> <SimpleWhenClause>

<SearchedWhenClause>::= WHEN <Expression> THEN <CaseResult>
                     |  WHEN <Expression> THEN <CaseResult> <SearchedWhenClause>

<CaseResult>::= <MathAddExpression>
<ElseClause> ::= ELSE <CaseResult>
              |  
! ------------------------------ CASE rules END ------------------------
<IndexedExpression>::= Path '[' <Expression> ']' '.' Path
                    |  Path '[' <Expression> ']' '.' Identifier
                    |  Path '[' <Expression> ']'

<StringValueExpression>::= StringLiteral | Parameter

!----- <ConcatenationExpression>::= <StringValueExpression> '||' <StringValueExpression>

<Value>       ::= Identifier
               |  Path
               |  <StringValueExpression>
               |  IntegerLiteral
               |  FloatLiteral
               |  HexLiteral
               |  NULL
               |  TRUE
               |  FALSE
               |  <Tuple>
               |  <AggregateExpression>
               |  <FunctionExpression>
               |  <CaseExpression>
               |  <IndexedExpression>
               |  <CollectionExpression>

<Tuple> ::= '(' <SelectStatement> ')'
         |  '(' <ExpressionList> ')'

<ExpressionList> ::= <Expression> ',' <ExpressionList>
                  |  <Expression>
